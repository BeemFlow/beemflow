name: digikey_cost_estimator
description: |
  Digi-Key Cost Estimator - Production Ready

  Automated BOM pricing workflow
  Processes ALL components in a Google Sheets BOM, searches Digi-Key for current
  pricing and availability, then updates the spreadsheet with cost estimates.

  Setup Instructions:
  1. Create a Google Sheet with your BOM structure:
    - Column A: Component/Part Number
    - Column B: Quantity
    - Column C: Unit Cost (will be populated)
    - Column D: Total Cost (will be populated)
    - Column E: Availability Status (will be populated)
    - Get sheet ID from URL: https://docs.google.com/spreadsheets/d/[SHEET_ID]/edit
    - Update bom_sheet_id variable below
  2. Set environment variables: DIGIKEY_CLIENT_ID, DIGIKEY_CLIENT_SECRET, GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET
  3. Authorize OAuth: beemflow oauth authorize google && beemflow oauth authorize digikey
  4. Deploy: beemflow flows deploy digikey_cost_estimator
  5. Run: beemflow flows start digikey_cost_estimator

version: 2.0.0
on: cli.manual

vars:
  bom_sheet_id: "GOOGLE_SHEET_ID_HERE"
  bom_sheet_name: "BOM"
  bom_start_row: 2
  bom_end_row: 100
  price_column: "C"
  total_column: "D"
  status_column: "E"

steps:
  # ============================================================================
  # STEP 1: Read BOM from Google Sheets
  # ============================================================================
  - id: read_bom
    use: google_sheets.values.get
    with:
      spreadsheetId: "{{ vars.bom_sheet_id }}"
      range: "{{ event.sheet_range || vars.bom_sheet_name + '!A' + vars.bom_start_row + ':B' + vars.bom_end_row }}"
      valueRenderOption: "UNFORMATTED_VALUE"

  # ============================================================================
  # STEP 2: Process All Components with forEach
  # ============================================================================
  - id: process_components
    foreach: "{{ read_bom.values }}"
    as: "component"
    parallel: false
    do:
      # ------------------------------------------------------------------------
      # 2a. Search Digi-Key for component
      # ------------------------------------------------------------------------
      - id: search_digikey
        use: digikey.search.keyword
        with:
          Keywords: "{{ component[0] }}"
          RecordCount: 1
          RecordStartPosition: 0

      # ------------------------------------------------------------------------
      # 2b. Extract search results
      # ------------------------------------------------------------------------
      - id: extract_results
        use: core.echo
        with:
          part_number: "{{ component[0] }}"
          quantity: "{{ component[1] }}"
          row_number: "{{ component_index + vars.bom_start_row }}"
          found: "{{ search_digikey.Products and search_digikey.Products | length > 0 and search_digikey.Products[0].ProductVariations and search_digikey.Products[0].ProductVariations | length > 0 }}"
          digikey_part: "{{ search_digikey.Products[0].ProductVariations[0].DigiKeyProductNumber if (search_digikey.Products and search_digikey.Products | length > 0 and search_digikey.Products[0].ProductVariations and search_digikey.Products[0].ProductVariations | length > 0) else '' }}"

      # ------------------------------------------------------------------------
      # 2c. Get detailed pricing (only if found)
      # ------------------------------------------------------------------------
      - id: get_details
        use: digikey.product.details
        with:
          partNumber: "{{ extract_results.digikey_part }}"
          Includes: "StandardPricing,QuantityAvailable"
        if: "{{ extract_results.found }}"

      # ------------------------------------------------------------------------
      # 2d. Calculate optimal pricing tier
      # ------------------------------------------------------------------------
      - id: calculate_pricing
        use: core.echo
        with:
          quantity_needed: "{{ component[1] }}"
          # Find best price tier for the quantity
          # Using first tier as example - production would implement tier matching
          unit_price: "{{ get_details.ProductVariations[0].StandardPricing[0].UnitPrice if (get_details.ProductVariations and get_details.ProductVariations | length > 0 and get_details.ProductVariations[0].StandardPricing and get_details.ProductVariations[0].StandardPricing | length > 0) else 0 }}"
          total_cost: "{{ (get_details.ProductVariations[0].StandardPricing[0].UnitPrice * component[1]) if (get_details.ProductVariations and get_details.ProductVariations | length > 0 and get_details.ProductVariations[0].StandardPricing and get_details.ProductVariations[0].StandardPricing | length > 0) else 0 }}"
          quantity_available: "{{ get_details.QuantityAvailable if get_details.QuantityAvailable else 0 }}"
          availability: "{{ 'In Stock' if (get_details.QuantityAvailable and get_details.QuantityAvailable >= component[1]) else ('Limited Stock' if (get_details.QuantityAvailable and get_details.QuantityAvailable > 0) else 'Out of Stock') }}"
        if: "{{ extract_results.found }}"

      # ------------------------------------------------------------------------
      # 2e. Update unit price in sheet
      # ------------------------------------------------------------------------
      - id: update_unit_price
        use: google_sheets.values.update
        with:
          spreadsheetId: "{{ vars.bom_sheet_id }}"
          range: "{{ vars.bom_sheet_name }}!{{ vars.price_column }}{{ component_index + vars.bom_start_row }}"
          values:
            - ["{{ calculate_pricing.unit_price }}"]
        if: "{{ extract_results.found }}"

      # ------------------------------------------------------------------------
      # 2f. Update total cost in sheet
      # ------------------------------------------------------------------------
      - id: update_total_cost
        use: google_sheets.values.update
        with:
          spreadsheetId: "{{ vars.bom_sheet_id }}"
          range: "{{ vars.bom_sheet_name }}!{{ vars.total_column }}{{ component_index + vars.bom_start_row }}"
          values:
            - ["{{ calculate_pricing.total_cost }}"]
        if: "{{ extract_results.found }}"

      # ------------------------------------------------------------------------
      # 2g. Update availability status
      # ------------------------------------------------------------------------
      - id: update_availability
        use: google_sheets.values.update
        with:
          spreadsheetId: "{{ vars.bom_sheet_id }}"
          range: "{{ vars.bom_sheet_name }}!{{ vars.status_column }}{{ component_index + vars.bom_start_row }}"
          values:
            - ["{{ calculate_pricing.availability }}"]
        if: "{{ extract_results.found }}"

      # ------------------------------------------------------------------------
      # 2h. Mark not found components
      # ------------------------------------------------------------------------
      - id: mark_not_found
        use: google_sheets.values.update
        with:
          spreadsheetId: "{{ vars.bom_sheet_id }}"
          range: "{{ vars.bom_sheet_name }}!{{ vars.status_column }}{{ component_index + vars.bom_start_row }}"
          values:
            - ["Not Found on Digi-Key"]
        if: "{{ !extract_results.found }}"

  # ============================================================================
  # STEP 3: Calculate BOM Totals
  # ============================================================================
  - id: calculate_totals
    use: google_sheets.values.get
    with:
      spreadsheetId: "{{ vars.bom_sheet_id }}"
      range: "{{ vars.bom_sheet_name }}!{{ vars.total_column }}{{ vars.bom_start_row }}:{{ vars.total_column }}{{ vars.bom_end_row }}"
      valueRenderOption: "UNFORMATTED_VALUE"

  # ============================================================================
  # STEP 4: Return Summary
  # ============================================================================
  - id: complete
    use: core.echo
    with:
      status: "success"
      processed_items: "{{ read_bom.values.length }}"
      total_bom_cost: "{{ calculate_totals.values != null ? calculate_totals.values.flat().filter(v => typeof v === 'number').reduce((sum, val) => sum + val, 0) : 0 }}"
      message: "All BOM components processed and priced successfully"
      timestamp: "{{ new Date().toISOString() }}"

# ============================================================================
# EXAMPLE USAGE
# ============================================================================
#
# Basic run (uses default range):
# beemflow flows start digikey_cost_estimator
#
# Custom range:
# beemflow flows start digikey_cost_estimator --event '{"sheet_range": "BOM!A2:B20"}'
#
# ============================================================================
# GOOGLE SHEETS SETUP
# ============================================================================
#
# Create: "Digi-Key Cost Estimator BOM"
#
# Tab: "BOM"
# Headers (Row 1):
#   A: Component/Part Number
#   B: Quantity
#   C: Unit Cost
#   D: Total Cost
#   E: Availability
#
# Example Data (Row 2+):
#   STM32H743VIT6 | 100 | [auto] | [auto] | [auto]
#   744031100     | 500 | [auto] | [auto] | [auto]
#
# ============================================================================
# DEPLOYMENT CHECKLIST
# ============================================================================
#
# Environment Setup:
# [ ] Create Digi-Key developer account (developer.digikey.com)
# [ ] Subscribe to Product Information API v4
# [ ] Create Google Cloud project with Sheets API enabled
# [ ] Set environment variables:
#       export DIGIKEY_CLIENT_ID="your_digikey_client_id"
#       export DIGIKEY_CLIENT_SECRET="your_digikey_client_secret"
#       export GOOGLE_CLIENT_ID="your_google_client_id"
#       export GOOGLE_CLIENT_SECRET="your_google_client_secret"
#
# Google Sheets:
# [ ] Create spreadsheet with BOM structure above
# [ ] Update vars.bom_sheet_id with your Sheet ID
#
# OAuth Authorization:
# [ ] beemflow oauth authorize google
# [ ] beemflow oauth authorize digikey
#
# Deployment:
# [ ] beemflow flows deploy digikey_cost_estimator
# [ ] beemflow flows start digikey_cost_estimator (test run)
#
# ============================================================================
# PRODUCTION FEATURES
# ============================================================================
#
# âœ… Implemented:
# - Batch processing with forEach (all BOM rows)
# - Parallel execution support (set parallel: true)
# - Error handling (components not found)
# - Availability checking (In Stock/Limited/Out of Stock)
# - Total BOM cost calculation
# - Timestamp tracking
#
# ðŸ”„ Optional Enhancements:
# 1. Price Tier Optimization: Implement smart tier selection based on quantity
# 2. Multi-Distributor: Add Mouser, Arrow as fallbacks
# 3. Caching: Cache pricing data for repeated runs
# 4. Notifications: Slack/email alerts on completion
# 5. Scheduling: Run automatically (daily/weekly)
# 6. Historical Tracking: Log pricing changes over time
# 7. Currency Conversion: Support international currencies
# 8. Profit Margin: Calculate markup and profit
#
# ============================================================================
